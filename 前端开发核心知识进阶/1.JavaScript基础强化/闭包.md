## 闭包

```javascript
// 暂时性死区会在块级作用域中发生,在函数参数的默认值处也会发生
function foo(arg1) {
    let arg1;
}

// 等效于
function foo(arg1) {
    var arg1
    let arg1;
}

foo('args');
```

null 和 undefined 的区别

undefined 作为参数传给函数时,如果函数有对应的默认值,则会取默认值
null 作为参数传给函数时,则会替代默认值

JavaScript 执行: 1.代码预编译(变量声明,声明提升,非函数表达式的函数声明提升,作用域在这个阶段确定) 2.代码编译

```javascript
// 这个非函数表达式(会发生函数声明提升)
function test() {
  console.log('test1')
}

// 这个是函数表达式
var test = function() {
  console.log('test2')
}
```

和

```javascript
var test = function() {
  console.log('test2')
}

// 这个非函数表达式(会发生函数声明提升)
function test() {
  console.log('test1')
}
```

等效于

```javascript
var test
test = function() { 
  console.log('test1')
}

test = function() {
  console.log('test2')
}
```

作用域链是在执行上下文的创建阶段完全生成
```javascript
// 当 for 和 setTimeout 结合使用的时候,就会出现看起来异常的现象
for (var i = 0; i < 10; i++) {
    setTimeout(() => {
        console.log(i); // 输出 10 次 10
    });
}

for (let i = 0; i < 10; i++) {
    setTimeout(() => {
        console.log(i); // 输出 0~9
    });
}

for (var i = 0; i < 10; i++) {
    setTimeout((i) => {
        console.log(i) // 输出 0~9
    }, 0, i);
}

for (var i = 0; i < 10; i++) {
    setTimeout(((i) => {
        console.log('i out', i)
        return () => {
            console.log('i in', i);
        };
    })(i));
}
// 输出 i out 0~9
// 输出 i in 0~9
```

```javascript
// todo 疑问题
const foo = () => {
    var arr = [];
    for (var i = 0; i < 10; i++) {
        arr[i] = function() {
            console.log('i', i); // i 10
        };
    }

    return arr[0];
};

foo()();
```

```javascript
// todo 疑问题
var fn = null;
const foo = () => {
    var a = 2;
    function innerFoo() {
        console.log(a);
    };
    // 修改了全局 fn, 同时保留了 a,所以在后续 bar 执行的时候,就可以打印出 a 的值
    fn = innerFoo
};

const bar = () => {
    fn();
};

foo();
bar();
```

等效于下面

```JavaScript
var fn = null;
const foo = () => {
    var a = 2;
    // 修改了全局 fn, 同时保留了 a,所以在后续 bar 执行的时候,就可以打印出 a 的值
    fn = function() {
        console.log(a);
    };
};

const bar = () => {
    fn();
};

foo();
bar();
```

```javascript
// 疑问题
var fn = null;
const foo = () => {
    var a = 2;
    // 修改了全局 fn, 同时保留了 a,所以在后续 bar 执行的时候,就可以打印出 a 的值
    fn = function () {
        console.log(c); // c is not defined
        console.log(a); // 2
    };
};

const bar = () => {
    var c = 100 // Error c is not defined
    fn();
};

foo();
bar();
```
