## 闭包

作用域就是语言指定的,在特殊情况下如何查找变量的规则

ES6 之前 JavaScript 只有函数作用域和全局作用域

如果需要读取变量的值,就近在函数内部查找,如果找不到就到 外一层 去查找,如果依然找不到就继续向外,直到到了全局作用域还没找到,那就只能报错 Uncaught ReferenceError: xx is not 

变量作用域的查找是一个扩散的过程,逐层递进(作用域链)

块级作用域和暂时性死区

var, function 会变量提升
let, const 不会变量提升(也就会发生 TDZ temporal dead zone 暂时性死区: 函数的开始到 let/const 语句之间都访问不到声明的那个值)
 

```javascript
// 暂时性死区会在块级作用域中发生,在函数参数的默认值处也会发生
function foo(arg1 = arg2, arg2) {
    console.log('arg1', arg1)
    console.log('arg2', arg2)
}

foo(undefined, 'test1') // Uncaught ReferenceError: arg2 is not defined
foo(null, 'test2') // 正常输出 arg1 null arg2 test2
```
null 和 undefined 的区别

undefined 作为参数传给函数时,如果函数有对应的默认值,则会取默认值
null 作为参数传给函数时,则会替代默认值

```javascript
function foo(arg1) {
  let arg1
}
foo('test1')

// 形参在这里的作用就等价于加了一个 var
function foo(arg1) {
    var arg1
    let arg1
}
```

执行上下文就是当前代码的执行环节/作用域
    执行上下文包含了作用域链

JavaScript 执行: 1.代码预编译(变量声明,声明提升,非函数表达式的函数声明提升,作用域在这个阶段确定) 2.代码执行

```javascript
// 这个非函数表达式(会发生函数声明提升)
function test() {
  console.log('test1')
}

// 这个是函数表达式
var test = function() {
  console.log('test2')
}
```

和

```javascript
var test = function() {
  console.log('test2')
}

// 这个非函数表达式(会发生函数声明提升)
function test() {
  console.log('test1')
}
```

等效于

```javascript
var test
test = function() { 
  console.log('test1')
}

test = function() {
  console.log('test2')
}
```

作用域链是在执行上下文的创建阶段完全生成
```javascript
// 当 for 和 setTimeout 结合使用的时候,就会出现看起来异常的现象
for (var i = 0; i < 10; i++) {
    setTimeout(() => {
        console.log(i); // 输出 10 次 10
    });
}

for (let i = 0; i < 10; i++) {
    setTimeout(() => {
        console.log(i); // 输出 0~9
    });
}

for (var i = 0; i < 10; i++) {
    setTimeout((i) => {
        console.log(i) // 输出 0~9
    }, 0, i);
}

for (var i = 0; i < 10; i++) {
    setTimeout(((i) => {
        console.log('i out', i)
        return () => {
            console.log('i in', i);
        };
    })(i));
}
// 输出 i out 0~9
// 输出 i in 0~9
```

```javascript
// todo 疑问题
const foo = () => {
    var arr = [];
    for (var i = 0; i < 10; i++) {
        arr[i] = function() {
            console.log('i', i); // i 10
        };
    }

    return arr[0];
};

foo()();
```

```javascript
// todo 疑问题
var fn = null;
const foo = () => {
    var a = 2;
    function innerFoo() {
        console.log(a);
    };
    // 修改了全局 fn, 同时保留了 a,所以在后续 bar 执行的时候,就可以打印出 a 的值
    fn = innerFoo
};

const bar = () => {
    fn();
};

foo();
bar();
```

等效于下面

```JavaScript
var fn = null;
const foo = () => {
    var a = 2;
    // 修改了全局 fn, 同时保留了 a,所以在后续 bar 执行的时候,就可以打印出 a 的值
    fn = function() {
        console.log(a);
    };
};

const bar = () => {
    fn();
};

foo();
bar();
```

```javascript
// 疑问题
var fn = null;
const foo = () => {
    var a = 2;
    // 修改了全局 fn, 同时保留了 a,所以在后续 bar 执行的时候,就可以打印出 a 的值
    fn = function () {
        console.log(c); // c is not defined
        console.log(a); // 2
    };
};

const bar = () => {
    var c = 100 // Error c is not defined
    fn();
};

foo();
bar();
```
